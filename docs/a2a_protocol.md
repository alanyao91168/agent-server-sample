# A2A (Agent-to-Agent) 协议规范

## 1. 引言

A2A (Agent-to-Agent) 协议定义了 AI 智能体之间以及智能体与客户端应用程序之间进行交互的标准化通信机制。本协议旨在促进多智能体系统中的互操作性、模块化和可扩展性。

## 2. 核心原则

*   **异步通信**: 智能体之间采用异步通信，以避免阻塞操作。
*   **面向消息**: 所有交互都基于结构化消息。
*   **无状态交互（尽可能）**: 最小化智能体之间的状态依赖，以提高可扩展性和弹性。
*   **可扩展性**: 协议应易于扩展，以适应新的消息类型和交互模式。
*   **安全性**: 应考虑安全通信机制（例如，认证、加密）。

## 3. 消息结构

所有 A2A 消息都遵循通用的 JSON 结构。

```json
{
  "protocol_version": "1.0",
  "message_id": "uuid-v4-string",
  "timestamp": "ISO 8601 datetime string",
  "sender_id": "agent-id-string",
  "receiver_id": "agent-id-string" | "broadcast",
  "message_type": "string (例如, 'request', 'response', 'event', 'error')",
  "payload": {
    // 根据 message_type 变化
  },
  "metadata": {
    // 可选: 额外的上下文或路由信息
  }
}
```

### 3.1. 字段解释

*   **`protocol_version`**: (字符串) 使用的 A2A 协议版本（例如，“1.0”）。
*   **`message_id`**: (字符串) 消息的唯一标识符（建议使用 UUID v4）。
*   **`timestamp`**: (字符串) ISO 8601 格式的日期时间字符串，指示消息发送时间。
*   **`sender_id`**: (字符串) 发送消息的智能体标识符。
*   **`receiver_id`**: (字符串) 预期接收智能体的标识符。对于所有监听智能体都应接收的消息，可以是“broadcast”。
*   **`message_type`**: (字符串) 定义消息的性质。常见类型包括：
    *   `request`: 智能体请求另一个智能体执行操作或提供信息。
    *   `response`: 对 `request` 消息的回复。
    *   `event`: 智能体广播一个其他智能体可能感兴趣的事件。
    *   `error`: 指示在处理上一条消息时发生错误。
*   **`payload`**: (对象) 消息的主要内容，根据 `message_type` 进行结构化。
*   **`metadata`**: (对象, 可选) 用于上下文、路由或其他非核心信息的额外键值对。

## 4. 常见消息类型和负载

### 4.1. 请求消息 (Request Message)

当一个智能体需要另一个智能体执行操作或提供数据时使用。

```json
{
  "message_type": "request",
  "payload": {
    "action": "string (例如, '处理数据', '获取状态', '执行任务')",
    "parameters": {
      // 针对特定操作的键值对参数
    }
  }
}
```

### 4.2. 响应消息 (Response Message)

用于回复 `request` 消息。应在其元数据中包含原始请求的 `message_id` 以进行关联。

```json
{
  "message_type": "response",
  "payload": {
    "status": "string (例如, '成功', '失败', '进行中')",
    "result": {
      // 请求操作返回的数据
    },
    "error": {
      // 如果状态为 '失败'，则包含错误详情
    }
  },
  "metadata": {
    "correlation_id": "原始请求消息ID"
  }
}
```

### 4.3. 事件消息 (Event Message)

用于广播多个智能体可能感兴趣的信息或状态变化。`receiver_id` 通常为“broadcast”。

```json
{
  "message_type": "event",
  "payload": {
    "event_name": "string (例如, '数据已处理', '智能体在线', '任务完成')",
    "event_data": {
      // 与事件相关的数据
    }
  }
}
```

### 4.4. 错误消息 (Error Message)

用于发出错误信号。可以是请求的响应，也可以是主动的错误通知。

```json
{
  "message_type": "error",
  "payload": {
    "code": "string (例如, '无效负载', '智能体不可用', '处理失败')",
    "message": "string (人类可读的错误描述)",
    "details": {
      // 可选: 额外的错误上下文
    }
  },
  "metadata": {
    "correlation_id": "原始请求消息ID" // 如果此错误是对请求的响应
  }
}
```

## 5. 通信通道

A2A 协议是传输无关的，这意味着它可以通过各种通信通道实现，例如：

*   **HTTP/HTTPS**: 用于 RESTful 或基于 WebSocket 的通信。
*   **消息队列**: (例如，RabbitMQ, Kafka) 用于健壮的异步消息传递。
*   **gRPC**: 用于高性能、语言无关的通信。
*   **共享内存/IPC**: 用于在同一机器上运行的智能体。

传输层的选择取决于多智能体系统的具体要求（例如，延迟、吞吐量、可靠性、安全性）。

## 6. 智能体发现与注册

智能体需要机制来发现其他智能体并注册其能力。这可以通过以下方式实现：

*   **集中式注册中心**: 一个专门的服务，智能体在此注册自己并查询其他智能体。
*   **广播/多播**: 智能体宣布其存在和能力。
*   **配置**: 静态配置已知智能体。

## 7. 安全考虑

*   **认证**: 验证通信智能体的身份。
*   **授权**: 控制智能体被允许执行哪些操作。
*   **加密**: 保护消息内容免受窃听。
*   **完整性**: 确保消息未被篡改。

## 8. 未来增强

*   **语义互操作性**: 负载内容的标准化本体或模式。
*   **协议协商**: 智能体协商协议版本和能力。
*   **服务质量 (QoS)**: 保证消息传递、排序等的机制。